<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>
The Reactive Machine | Activities
</title>
    
<link rel="stylesheet" href="/css/style.af54df87ff3bd3c2c433dbfd4c3a7ecb417849c15384eba8e9fb6f7b5a9de6e2.css">
<link rel="stylesheet" href="/css/syntax.de5a118cd688caecccb0905dc27fdf35ea42b86621e7f077f96723087430564e.css">
<link rel="shortcut icon" href="/img/logo-icon.png">

  </head>
  <body class="page has-navbar-fixed-top">
    <main class="main">
      

<nav class="navbar is-fixed-top">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="http://reactive-machine.org">
        <img src="/img/logo-icon.png">
      </a>

      <a class="navbar-item has-text-primary has-text-weight-bold" href="http://reactive-machine.org">
        Reactive Machine
      </a>

      <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbar-menu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbar-menu" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="/docs">
          Docs
        </a>
        <a class="navbar-item" href="https://github.com/Microsoft/ReactiveMachine">
          GitHub
        </a>
      </div>
    </div>
  </div>
</nav>


      
<section class="hero is-primary">
  <div class="hero-body">
    <div class="container">
      <p class="title is-size-1 is-size-2-mobile has-text-weight-light is-spaced">
        Activities
      </p>
      <p class="subtitle is-size-3 is-size-4-mobile has-text-weight-light">
        encapsulate nondeterminism and external interactions
      </p>
    </div>
  </div>
</section>
  

<nav class="tabs">
  <div class="container">

    <ul> 
          <li>
            <a href="/docs/">
              Overview
            </a>
          </li> 
          <li class="is-active">
            <a href="/docs/model/">
              Programming Model
            </a>
          </li> 
          <li>
            <a href="/docs/hosts/">
              Hosts
            </a>
          </li> 
          <li>
            <a href="/docs/examples/">
              Examples
            </a>
          </li> 
          <li>
            <a href="/docs/motivation/">
              Motivation
            </a>
          </li>
    </ul>
  </div>
</nav>



    
       
      
          <nav class="tabs" style="margin-top: -25px;">
            <div class="container">
              <ul>
        
                <li class="">
                    <a href="/docs/model-orchestrations/">Orchestrations</a>
                </li>
        
                <li class="is-active">
                    <a href="/docs/model-activities/">Activities</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-states/">States</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-affinities/">Affinities</a>
                </li>
        
                <li class="">
                    <a href="/docs/model-events/">Events</a>
                </li>
        
              </ul>
            </div>
          </nav>
      
    

    
       
      
    

    
       
      
    


<div class="container docs-container">
  <div class="content">
    

<p>Activities are classes that define how to execute some task in an <code>Execute</code> method, and may include nondeterminism and I/O.</p>

<h3 id="example-1-calling-an-external-service">Example 1 : Calling an External Service</h3>

<p>We can define an activity that reads the contents of a blob from Azure Storage:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">ReadBlob</span> <span class="p">:</span> <span class="n">IAtLeastOnceActivity</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="c1">// the input to the activity
</span><span class="c1"></span>    <span class="k">public</span> <span class="kt">string</span> <span class="n">Path</span><span class="p">;</span>

    <span class="c1">// must specify a time limit
</span><span class="c1"></span>    <span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">TimeLimit</span> <span class="p">=&gt;</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">&#34;Reading From Storage&#34;</span><span class="p">);</span>
        <span class="n">CloudBlockBlob</span> <span class="n">blobReference</span> <span class="p">=</span> <span class="n">Utils</span><span class="p">.</span><span class="n">GetAzureBlob</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
        <span class="kt">var</span> <span class="n">content</span> <span class="p">=</span> <span class="k">await</span> <span class="n">blobReference</span><span class="p">.</span><span class="n">DownloadTextAsync</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">content</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p><strong>Timeouts</strong>. Activities must specify a TimeLimit property. A timer is automatically started when the activity starts executing. If the activity does not finish before the time limit is reached, a <code>System.TimeoutException</code> is thrown. In general, using timeouts is helpful to guarantee that orchestrations can make progress.</p>

<p><strong>Context object</strong>. Just like for orchestrations, the <code>Execute</code> method is passed a context. However, this context has a lot fewer methods. Essentially, it just supports logging (via <code>context.Logger</code>) and accessing configuration information (via <code>context.GetConfiguration&lt;TConfiguration&gt;()</code>).</p>

<h3 id="example-2-performing-a-cpu-intensive-activity">Example 2: Performing a CPU-intensive activity</h3>

<p>In the <code>Applications/Miner.Service</code> project, we demonstrate a hash-space mining application.  Searching for a hash collision is CPU intensive, so we use an orchestration to break the search space into small portions, and then run an activity for searching each portion. The runtime runs each portion on the thread pool.</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">namespace</span> <span class="nn">Miner.Service</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">SearchPortion</span> <span class="p">:</span> <span class="n">IAtLeastOnceActivity</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;&gt;</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">TimeSpan</span> <span class="n">TimeLimit</span> <span class="p">=&gt;</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromSeconds</span><span class="p">(</span><span class="m">30</span><span class="p">);</span>
 
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Target</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">Start</span><span class="p">;</span>
        <span class="k">public</span> <span class="kt">long</span> <span class="n">Count</span><span class="p">;</span>

        <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Starting portion [{Start},{Start + Count})&#34;</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">long</span><span class="p">&gt;();</span>
            <span class="c1">// search given range for a hash collision
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="n">Start</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Start</span> <span class="p">+</span> <span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">GetHashCode</span><span class="p">()</span> <span class="p">==</span> <span class="n">Target</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">context</span><span class="p">.</span><span class="n">Logger</span><span class="p">.</span><span class="n">LogInformation</span><span class="p">(</span><span class="s">$&#34;Finished portion [{Start},{Start + Count})&#34;</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h2 id="activites-vs-orchestrations">Activites vs. Orchestrations</h2>

<p>Activities complement orchestrations in terms of what you are allowed to do inside <code>Execute</code>:</p>

<table>
<thead>
<tr>
<th></th>
<th>Activity</th>
<th>Orchestration</th>
</tr>
</thead>

<tbody>
<tr>
<td>Nondeterminism</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>External Calls</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Any type of I/O</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Long-running computations</td>
<td>✓</td>
<td>❌</td>
</tr>

<tr>
<td>Perform an operation</td>
<td>❌</td>
<td>✓</td>
</tr>

<tr>
<td>Fork an operation</td>
<td>❌</td>
<td>✓</td>
</tr>

<tr>
<td>Schedule an operation</td>
<td>❌</td>
<td>✓</td>
</tr>
</tbody>
</table>

<p>Activities also provide parallelism: they always run on the .NET thread pool, and are therefore appropriate for long-running CPU-intensive tasks.</p>

<h3 id="at-least-once-vs-at-most-once">At-least-once vs. At-most-once</h3>

<p>Activites allow nondeterminism to be effectively &ldquo;determinized.&rdquo;  Activities are logged by the system prior to starting execution, and the return values of activities are logged when the operation completes.  Under replay, requests are not reissued if they have already been issued and a value returned: instead, the return value in the log is used as the return value for the operation.</p>

<p>If a host resumes after failing in the middle of executing an activity, the system detects in the log that the activity started, but did not complete. The right thing to do in this case may depend on the specific purpose of the activity, i.e. it is application-dependent.</p>

<p>In most cases, the right thing to do is to simply restart the activity. By using the interface <code>IAtLeastOnceActivity&lt;string&gt;</code>, we indicate to the runtime that this is always the desired course of action.</p>

<p>Sometimes, it is desirable to take some special action rather than just restarting an activity. The interface <code>IAtMostOnceActivity&lt;TReturn&gt;</code> can be used for that:</p>
<div class="highlight"><pre class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MyActivity</span> <span class="p">:</span> <span class="n">IAtMostOnceActivity</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">Execute</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="p">...</span> <span class="c1">// regular execution
</span><span class="c1"></span>    <span class="p">}</span>
    
    <span class="k">public</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TReturn</span><span class="p">&gt;</span> <span class="n">AfterFault</span><span class="p">(</span><span class="n">IContext</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
         <span class="p">...</span> <span class="c1">// custom handling
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>The <code>AfterFault</code> handler is called when the runtime, during recovery, detects that this activity was previously started but did not complete. Inside the handler, we can take an appropriate action to deal with this situation. For example, we can perform some tests to figure out if the desired effect of the activity (e.g. creating a blob) has already taken place (i.e. the blob already exists), and re-execute it only if those tests indicate so.</p>

<p>Conceptually, the <code>AfterFault</code> handler provides us with a mechanism that can wrap external calls that are not idempotent or not exactly idempotent into a truly idempotent activity.</p>

  </div>
</div>


    </main>

    
<footer class="footer has-background-dark">
  <div class="container has-text-centered">
    <p class="is-size-5 is-size-6-mobile has-text-white-bis">
      &copy; 2018 Microsoft Corporation
    </p>
  </div>
</footer>

    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="/js/app.min.e119cad0205945173c83cdb2ffec7a581007a612e088c70bd62c7245ad7e58cb.js" integrity=""></script>

  </body>
</html>
